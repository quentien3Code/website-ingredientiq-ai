from rest_framework import serializers
from django.contrib.auth import authenticate

from panel.models import OnboardingQuestion
from .models import FAQ, AboutUS, Termandcondition, User,UserHealthPreference, privacypolicy, FoodLabelScan, Feedback, DepartmentContact, DeviceToken, NotificationTemplate, PushNotification, AppVersion
from django.views.decorators.csrf import csrf_exempt
from django.core.validators import validate_email
from django.core.exceptions import ValidationError as DjangoValidationError


class HealthPreferenceSerializer(serializers.ModelSerializer):
    threshold = serializers.CharField(required=True)

    class Meta:
        model = UserHealthPreference
        fields = ['preference_type', 'name', 'threshold']

    def validate_threshold(self, value):
        # Treat empty string or "NULL" as zero.
        if not value or value.strip().lower() == "null":
            return "0"
        return value

class SignupSerializer(serializers.ModelSerializer):
    confirm_password = serializers.CharField(write_only=True, required=True)
    terms_accepted = serializers.BooleanField(required=False, write_only=True)
    # Remove the old plain text fields (allergies, dietary_preferences, medical_conditions)
    # and add a nested field for health_preferences.
    health_preferences = HealthPreferenceSerializer(many=True, required=False)
    
    class Meta:
        model = User
        fields = (
            'id',
            'email', 
            'full_name',  
            'password', 
            'confirm_password', 
            'terms_accepted',
            'health_preferences',
        )
    
    def validate(self, data):
        if data.get('password') != data.get('confirm_password'):
            raise serializers.ValidationError({'confirm_password': 'Passwords do not match.'})
        data.pop('confirm_password')
        return data
    
    def create(self, validated_data):
        # Pop out the health preferences data if provided.
        health_prefs_data = validated_data.pop('health_preferences', [])
        user = User.objects.create_user(**validated_data)
        
        # Set terms acceptance if provided; default False when missing
        terms = validated_data.pop('terms_accepted', None) if 'terms_accepted' in validated_data else None
        user.is_terms = bool(terms) if terms is not None else False
        user.save()
        
        # Create health preferences for the user.
        for pref in health_prefs_data:
            UserHealthPreference.objects.create(user=user, **pref)
        
        return user

class LoginSerializer(serializers.Serializer):
    email_or_phone = serializers.CharField()
    password = serializers.CharField(write_only=True)

    def validate(self, data):
        identifier = data.get("email_or_phone")
        password = data.get("password")

        user = None

        # Check if identifier is an email
        try:
            validate_email(identifier)
            user = authenticate(email=identifier, password=password)
        except DjangoValidationError:
            # If not email, assume phone number
            try:
                user_obj = User.objects.get(phone_number=identifier)
                user = authenticate(email=user_obj.email, password=password)
            except User.DoesNotExist:
                pass

        if not user:
            raise serializers.ValidationError("Invalid email/phone or password")

        data["user"] = user
        return data

class ForgotPasswordRequestSerializer(serializers.Serializer):
    email = serializers.EmailField()

class VerifyOTPSerializer(serializers.Serializer):
    email = serializers.EmailField()
    otp = serializers.CharField(max_length=6)
    new_password = serializers.CharField(write_only=True)
    confirm_password = serializers.CharField(write_only=True)

    def validate(self, data):
        if data['new_password'] != data['confirm_password']:
            raise serializers.ValidationError("Passwords do not match.")
        return data
    
# class ChangeSerializer(serializers.Serializer):
#     old_password = serializers.CharField(write_only=True)
#     new_password = serializers.CharField(write_only=True)
#     confirm_new_password = serializers.CharField(write_only=True)

#     def validate(self, data):
#         new_password = data.get('new_password')
#         confirm_new_password = data.get('confirm_new_password')
#         if new_password != confirm_new_password:
#             raise serializers.ValidationError("New passwords do not match.")
#         return data

#     def validate_old_password(self, value):
#         user = self.context.get('request').user
#         if not user.check_password(value):
#             raise serializers.ValidationError("Old password is not correct.")
#         return value

class ChangePasswordSerializer(serializers.Serializer):
    new_password = serializers.CharField(write_only=True)
    confirm_password = serializers.CharField(write_only=True)

class AllergenDietaryCheckSerializer(serializers.Serializer):
    image = serializers.ImageField(
        help_text="Upload an image of the food label to check its safety."
    )

class UpdateUserProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('full_name', 'phone_number', 'allergies', 'dietary_preferences', 'medical_conditions')

class userPatchSerializer(serializers.ModelSerializer):
    profile_picture = serializers.ImageField(required=False, allow_null=True)
    phone_number = serializers.IntegerField(required=False,allow_null=True)
    full_name = serializers.CharField(required=False) 
    Dietary_preferences = serializers.CharField(required=False) 
    Health_conditions = serializers.CharField(required=False)
    Allergies = serializers.CharField(required=False)
    Health_Goals = serializers.CharField(required=False)
    Parental_status = serializers.CharField(required=False)
    Family_Health_Awareness = serializers.CharField(required=False)
    Emotional_Conection = serializers.CharField(required=False)
    Health_impact_awareness = serializers.CharField(required=False)
    Desired_outcome = serializers.CharField(required=False)
    Motivation = serializers.CharField(required=False)
    class Meta:
        model=User
        fields=['full_name','phone_number','profile_picture','Dietary_preferences','Health_conditions','Allergies','Health_Goals','Parental_status','Family_Health_Awareness','Emotional_Conection','Health_impact_awareness','Desired_outcome','Motivation']
    def validate_phone_number(self, value):
        user = self.instance  # the currently logged-in user
        if User.objects.exclude(pk=user.pk).filter(phone_number=value).exists():
            raise serializers.ValidationError("This phone number is already in use.")
        return value

class userGetSerializer(serializers.ModelSerializer):
    profile_picture = serializers.SerializerMethodField()
    questions_and_answers = serializers.SerializerMethodField()
    computed_full_name = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = [
            'id',
            'email',
            'full_name',
            'first_name',
            'last_name',
            'computed_full_name',
            'phone_number',
            'profile_picture',
            'questions_and_answers',
            'date_joined',
            'language',
            'subscription_plan',
            'notifications_enabled',
            'dark_mode',
            'privacy_settings_enabled',
            'has_answered_onboarding',
            'loves_app',
            'subscription_notifications_enabled',
            'account_deactivation_date',
            
            # 'food_label_scans'
        ]

    def get_profile_picture(self, obj):
        if obj.profile_picture:
            profile_picture_url = obj.profile_picture.url
            profile_picture_url = profile_picture_url.replace("https//", "")
            return profile_picture_url
        return None

    def get_computed_full_name(self, obj):
        # If we have first_name and last_name, combine them
        if obj.first_name and obj.last_name:
            return f"{obj.first_name} {obj.last_name}".strip()
        elif obj.first_name:
            return obj.first_name
        elif obj.last_name:
            return obj.last_name
        # Fallback to the stored full_name field
        elif obj.full_name:
            return obj.full_name
        # Final fallback for Apple users
        else:
            return "Apple User"

    def get_questions_and_answers(self, obj):
        user_answers = {
            'health': obj.Health_conditions,
            'allergy': obj.Allergies,
            'diet': obj.Dietary_preferences,
            'primary health goals': obj.Health_Goals,
            'parental status': obj.Parental_status,
            'family health awareness': obj.Family_Health_Awareness,
            'quality and safety of ingredients': obj.Emotional_Conection,
            'negative health symptoms': obj.Health_impact_awareness,
            'achive by using ingredientiq': obj.Desired_outcome,
            'ready to take control of health': obj.Motivation,
        }

        category_map = {
            'parent or caregiver': 'parental status',
            'Parental status': 'parental status',
            'safer meal planning': 'family health awareness',
            'Family_Health_Awareness': 'family health awareness',
        }

        questions = OnboardingQuestion.objects.prefetch_related('choices').all()
        data = []

        for question in questions:
            normalized_category = category_map.get(question.category.strip().lower(), question.category.strip().lower())
            user_answer_raw = user_answers.get(normalized_category, "")
            if user_answer_raw:
                if ',' in user_answer_raw and not any(
                    choice.choice_text.strip().lower() == user_answer_raw.strip().lower()
                    for question in OnboardingQuestion.objects.all()
                    for choice in question.choices.all()
                ):
                    user_selected = {ans.strip().lower() for ans in user_answer_raw.split(',')}
                else:
                    user_selected = {user_answer_raw.strip().lower()}
            else:
                user_selected = set()

            # user_selected = {ans.strip().lower() for ans in user_answer_raw.split(',')} if user_answer_raw else set()

            # print("\nDEBUG:")
            # print(f"Question: {question.question_text}")
            # print(f"Category: {question.category} â†’ Normalized: {normalized_category}")
            # print(f"User Raw Answer: {user_answer_raw}")
            # print(f"User Selected Set: {user_selected}")

            choices_data = []
            for choice in question.choices.all():
                choice_clean = choice.choice_text.strip().lower()
                is_selected = choice_clean in user_selected
                print(f"Choice: {choice_clean} | Selected: {is_selected}")
                choices_data.append({
                    "choice_text": choice.choice_text,
                    "is_selected": is_selected
                })

            data.append({
                "questionId": question.id,
                "question_text": question.question_text,
                "choices": choices_data
            })

        return data



class termsandconditionSerializer(serializers.ModelSerializer):
    class Meta:
        model=Termandcondition
        fields='__all__'

class privacypolicySerializer(serializers.ModelSerializer):
    class Meta:
        model=privacypolicy
        fields='__all__'

class FAQSerializer(serializers.ModelSerializer):
    class Meta:
        model = FAQ
        fields='__all__'

class AboutSerializer(serializers.ModelSerializer):
    class Meta:
        model = AboutUS
        fields='__all__'

class FoodLabelScanSerializer(serializers.ModelSerializer):
    scanned_at = serializers.SerializerMethodField()
    
    class Meta:
        model = FoodLabelScan
        fields = '__all__'
    
    def get_scanned_at(self, obj):
        """Format the scanned_at field as mm/dd/yyyy"""
        if obj.scanned_at:
            return obj.scanned_at.strftime('%m/%d/%Y')
        return None

class UserSettingsSerializer(serializers.ModelSerializer):
    profile_picture = serializers.SerializerMethodField()
    subscription_plan = serializers.SerializerMethodField()
    subscription_status = serializers.SerializerMethodField()
    premium_type = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = [
            'full_name', 'email', 'profile_picture',
            'notifications_enabled', 'dark_mode', 'language',
            'subscription_plan', 'subscription_status', 'premium_type',
            'privacy_settings_enabled', 'is_2fa_enabled', 'account_deactivation_date','subscription_notifications_enabled'
        ]
    
    def get_profile_picture(self, obj):
        if obj.profile_picture:
            url = obj.profile_picture.url
            return url.replace("https//https://", "https://")  # fix double https
        return None
    
    def get_subscription_plan(self, obj):
        try:
            subscription = obj.usersubscription
            return subscription.plan_name
        except:
            return "freemium"
    
    def get_subscription_status(self, obj):
        try:
            subscription = obj.usersubscription
            return subscription.status
        except:
            return "inactive"
    
    def get_premium_type(self, obj):
        try:
            subscription = obj.usersubscription
            return subscription.premium_type
        except:
            return None

class FeedbackSerializer(serializers.ModelSerializer):
    class Meta:
        model = Feedback
        fields = ['rating', 'comment']
        extra_kwargs = {
            'rating': {'required': True},
            'comment': {'required': True}
        }

    def validate_rating(self, value):
        if value < 1 or value > 5:
            raise serializers.ValidationError("Rating must be between 1 and 5")
        return value

class LoveAppSerializer(serializers.Serializer):
    loves_app = serializers.BooleanField(required=True)

class DepartmentContactSerializer(serializers.ModelSerializer):
    department_display = serializers.CharField(source='get_department_display', read_only=True)
    
    class Meta:
        model = DepartmentContact
        fields = ['id', 'department', 'department_display', 'contact_name', 'phone_number', 'email', 'available_hours', 'description', 'is_active']
class DeviceTokenSerializer(serializers.ModelSerializer):
    """Serializer for device token registration"""
    
    class Meta:
        model = DeviceToken
        fields = ['token', 'platform']
    
    def create(self, validated_data):
        # Get user from request context
        user = self.context['request'].user
        validated_data['user'] = user
        
        # Update or create device token
        device_token, created = DeviceToken.objects.update_or_create(
            user=user,
            token=validated_data['token'],
            defaults={
                'platform': validated_data['platform'],
                'is_active': True
            }
        )
        return device_token

class NotificationTemplateSerializer(serializers.ModelSerializer):
    """Serializer for notification templates"""
    
    notification_type_display = serializers.CharField(source='get_notification_type_display', read_only=True)
    
    class Meta:
        model = NotificationTemplate
        fields = [
            'id', 'notification_type', 'notification_type_display', 
            'title', 'body', 'icon', 'action_url', 'is_active',
            'created_at', 'updated_at'
        ]

class PushNotificationSerializer(serializers.ModelSerializer):
    """Serializer for push notification logs"""
    
    user_email = serializers.CharField(source='user.email', read_only=True)
    status_display = serializers.CharField(source='get_status_display', read_only=True)
    
    class Meta:
        model = PushNotification
        fields = [
            'id', 'user', 'user_email', 'notification_type', 
            'title', 'body', 'status', 'status_display',
            'firebase_message_id', 'error_message', 
            'sent_at', 'created_at'
        ]

class AppVersionSerializer(serializers.ModelSerializer):
    """Serializer for app versions"""
    
    platform_display = serializers.CharField(source='get_platform_display', read_only=True)
    
    class Meta:
        model = AppVersion
        fields = [
            'id', 'platform', 'platform_display', 'version', 
            'build_number', 'release_notes', 'is_critical_update',
            'is_current', 'released_at'
        ]

class CustomNotificationSerializer(serializers.Serializer):
    """Serializer for sending custom notifications"""
    
    user_ids = serializers.ListField(
        child=serializers.IntegerField(),
        help_text="List of user IDs to send notification to"
    )
    
    # Template-based notification fields
    template_type = serializers.CharField(
        max_length=50, 
        required=False,
        help_text="Notification template type to use (optional)"
    )
    user_data = serializers.JSONField(
        required=False, 
        default=dict,
        help_text="User data for template placeholder replacement"
    )
    
    # Direct notification fields (required if not using template)
    title = serializers.CharField(
        max_length=100, 
        required=False,
        help_text="Notification title (required for direct notifications)"
    )
    body = serializers.CharField(
        required=False,
        help_text="Notification body (required for direct notifications)"
    )
    
    # Optional fields
    action_url = serializers.URLField(required=False, allow_blank=True)
    data = serializers.JSONField(required=False, default=dict)
    
    def validate(self, data):
        """
        Validate that either template_type is provided OR title and body are provided
        """
        template_type = data.get('template_type')
        title = data.get('title')
        body = data.get('body')
        
        if template_type:
            # Using template - title and body are optional
            return data
        elif title and body:
            # Direct notification - template_type is optional
            return data
        else:
            raise serializers.ValidationError(
                "Either 'template_type' must be provided, OR both 'title' and 'body' must be provided"
            )
    
    def validate_user_ids(self, value):
        if not value:
            raise serializers.ValidationError("At least one user ID is required")
        
        # Validate that all user IDs exist
        existing_users = User.objects.filter(id__in=value).count()
        if existing_users != len(value):
            raise serializers.ValidationError("Some user IDs do not exist")
        
        return value

class NotificationSettingsSerializer(serializers.ModelSerializer):
    """Serializer for user notification settings"""
    
    class Meta:
        model = User
        fields = ['notifications_enabled']

class NotificationToggleSerializer(serializers.ModelSerializer):
    """Serializer for subscription notification toggle"""
    
    class Meta:
        model = User
        fields = ['subscription_notifications_enabled']